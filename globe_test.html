<!DOCTYPE html>
<meta charset="utf-8">
<style>

.land {
    fill: rgb(117, 87, 57);
    stroke-opacity: 1;
}

.countries path {
    stroke: rgb(80, 64, 39);
    stroke-linejoin: round;
    stroke-width:.5;
    fill: rgb(117, 87, 57);
    opacity: .1;
}

.countries path:hover {
    fill-opacity:.1;
    stroke-width:1;
    opacity: 1;
}


.graticule {
    fill: none;
    stroke: black;
    stroke-width:.5;
    opacity:.2;
}

.labels {
    font: 8px sans-serif;
    fill: black;
}

.noclicks {
    pointer-events:none;
}

.point{
    opacity:.6;
}

.fog{
    fill: url(#fog);
    fill-rule: evenodd;
    opacity: 0.85;
}
.fogMask{
    fill: black;
    fill-rule: evenodd;
}

</style>

<body>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://d3js.org/queue.v1.min.js"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>
    <script src="troopClass.js"></script>
    <script src="https://d3js.org/d3-geo.v1.min.js"></script>
    <script>
    d3.select(window)
        .on("mousemove", mousemove)
        .on("mouseup", mouseup);

    // var width = 960, height = 500;
    var width = screen.width * 0.95, height = screen.height * 0.95;

    var proj = d3.geo.orthographic()
        .scale(220)
        .translate([width / 2, height / 2])
        .clipAngle(90);
    var preD, postD, pntD;
    // projection(location): that coordinates -> cartesian coordinates in pixels
    // projection.invert(point): cartesian coordinates [x,y] -> [longtitude, latitude]
    // projection.rotate([yaw, pitch, roll]) -> sets projection's three-axis rotation
    // projection.scale([scale]) -> scale factor of projection
    // projection.clipAngle -> semi-fog of war, how much degree to displaya
    // projection.translate([x, y]) -> offset projection's center coordinate
    var path = d3.geo.path().projection(proj).pointRadius(1);
    // d3.geo.path() -> given geoJSON object -> generate a SVG path
    var graticule = d3.geo.graticule();
    // graticule -> vertical and horizontal grid lines 
    // -> returns a GeoJSON MultiLineString Geometry object representing all meridians and parallels
    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height)
        .on("mousedown", mousedown);
       
    // asynchronous task assignment.
    queue()
        .defer(d3.json, "https://raw.githubusercontent.com/jonataswalker/map-utils/master/data/json/world-110m.json")
        .defer(d3.json, "https://raw.githubusercontent.com/DixonCider/fongmun2017/master/places.json")
        .await(ready);
    // svg -> defs: graphical macro for later use (not rendered immdiately)
    var vision = class vision {
        constructor(id, lat, lon, r){
            this.lat = lat;
            this.lon = lon;
            this.r = r;
            this.id = id;
            this.enable();
        }
        update(key, val) {
            if (this.hasOwnProperty(key)) {
                this[key] = val;
                var fogMaskCircle = d3.geoCircle().center([this.lat, this.lon]).radius(this.r);
                svg.select("#" + this.id)
                    .datum(fogMaskCircle())
                    .attr("d", path);
            }
        }
        disable(){
            svg.select("#" + this.id)
                .data([])
                .exit()
                .remove();
        }
        enable(){
            if (svg.select("#" + this.id)[0][0] == null) {
                var fogMaskCircle = d3.geoCircle().center([this.lat, this.lon]).radius(this.r);
                svg.select("#visionMask").append("path")
                    .datum(fogMaskCircle())
                    .attr("d", path)
                    .attr("class", "fogMask")
                    .attr("id", this.id)
                    .style("fill", "black");
            }
        }
    }
    function ready(error, world, places) {
        var ocean_fill = svg.append("defs").append("radialGradient")
            .attr("id", "ocean_fill")
            .attr("cx", "75%")
            .attr("cy", "25%");
        // center of the ocean gradient
        ocean_fill.append("stop").attr("offset", "5%").attr("stop-color", "#ddf");
        ocean_fill.append("stop").attr("offset", "100%").attr("stop-color", "#9ab");
        // sunshine in the land
        var globe_highlight = svg.append("defs").append("radialGradient")
            .attr("id", "globe_highlight")
            .attr("cx", "75%")
            .attr("cy", "25%");
        globe_highlight.append("stop")
            .attr("offset", "5%").attr("stop-color", "#ffd")
            .attr("stop-opacity","0.6");
        globe_highlight.append("stop")
            .attr("offset", "100%").attr("stop-color", "#ba9")
            .attr("stop-opacity","0.2");
        var fogsize = 900;
        var fog = svg.append("defs").append("pattern")
            .attr("id", "fog")
            .attr("width", fogsize)
            .attr("height", fogsize)
            .attr("patternUnits", "userSpaceOnUse");
        fog.append("svg:image")
            .attr("xlink:href", "fog.webp")
            .attr("width", fogsize)
            .attr("height", fogsize)
            .attr("x", width / 3.5)
            .attr("y", height / 6);
        var globe_shading = svg.append("defs").append("radialGradient")
            .attr("id", "globe_shading")
            .attr("cx", "50%")
            .attr("cy", "40%");
        globe_shading.append("stop")
            .attr("offset","50%").attr("stop-color", "#9ab")
            .attr("stop-opacity","0")
        globe_shading.append("stop")
            .attr("offset","100%").attr("stop-color", "#3e6184")
            .attr("stop-opacity","0.3")
        var visionMask = svg.append("defs").append("mask")
            .attr("id", "visionMask");
            /*
        visionMask.append("circle")
            .attr("cx", width / 2).attr("cy", height / 2)
            .attr("r", proj.scale())
            .attr("class", "fogMask")
            .style("fill", "white");
            */
        var fogMotherMaskCircle = d3.geoCircle().center([0, 90]).radius(180);
        visionMask.append("path")
            .datum(fogMotherMaskCircle())
            .attr("d", path)
            .attr("class", "fogMask")
            .style("fill", "white");
        var fogMaskCircle = d3.geoCircle().center([120, 23.5]).radius(30);
        visionMask.append("path")
            .datum(fogMaskCircle())
            .attr("d", path)
            .attr("class", "fogMask")
            .style("fill", "black");
        /*
        visionMask.append("path")
            .data([fogMotherMaskCircle(), fogMaskCircle()])
            .attr("d", path)
            .attr("class", "fogMask")
            .style("fill", "white");
        */
        var visionClip = svg.append("defs").append("clipPath")
            .attr("id", "visionClip");
        visionClip.append("circle")
            .attr("cx", "300")
            .attr("cy", "300")
            .attr("r", "300");
        var drop_shadow = svg.append("defs").append("radialGradient")
            .attr("id", "drop_shadow")
            .attr("cx", "50%")
            .attr("cy", "50%");
        drop_shadow.append("stop")
            .attr("offset","20%").attr("stop-color", "#000")
            .attr("stop-opacity",".5")
        drop_shadow.append("stop")
            .attr("offset","100%").attr("stop-color", "#000")
            .attr("stop-opacity","0")
        // Shadow on the floor
        svg.append("ellipse")
            .attr("cx", width / 2 * 0.975).attr("cy", height / 2 * 1.6)
            .attr("rx", proj.scale()*.90)
            .attr("ry", proj.scale()*.25)
            .attr("class", "noclicks")
            .style("fill", "url(#drop_shadow)");
        // url(#patternDefinedInDefs)
        
        // ocean circle
        svg.append("circle")
            .attr("cx", width / 2).attr("cy", height / 2)
            .attr("r", proj.scale())
            .attr("class", "noclicks")
            .style("fill", "url(#ocean_fill)");
        // land color
        preD = topojson.feature(world, world.objects.land);
        svg.append("path")
            .datum(topojson.feature(world, world.objects.land))
            .attr("class", "land")
            .attr("d", path);
        postD = path(preD);
        // set verticals and parallel lines
        svg.append("path")
            .datum(graticule)
            .attr("class", "graticule noclicks")
            .attr("d", path);
        
        // points of locations
        pntD = places.features;
        svg.append("g").attr("class","points")
            .selectAll("text").data(places.features)
            .enter().append("path")
            .attr("class", "point")
            .attr("d", path);
        svg.append("g").attr("class","labels")
            .selectAll("text").data(places.features)
            .enter().append("text")
            .attr("class", "label")
            .text(function(d) { return d.properties.name })
        // append gray cover
        var fogCircle = d3.geoCircle().center([0,90]).radius(180);
        svg.append("path")
            .datum(fogCircle)
            .attr("class", "fog")
            .attr("d", path)
            .attr("mask", "url(#visionMask)");
        // sun shine land brighter
        svg.append("circle")
            .attr("cx", width / 2).attr("cy", height / 2)
            .attr("r", proj.scale())
            .attr("class","noclicks")
            .style("fill", "url(#globe_highlight)");
        // shadows on the side
        svg.append("circle")
            .attr("cx", width / 2).attr("cy", height / 2)
            .attr("r", proj.scale())
            .attr("class","noclicks")
            .style("fill", "url(#globe_shading)");
        position_labels();
    }
    /*
    function position_labels() { //how labels chage their angle
        var centerPos = proj.invert([width/2,height/2]);
        var arc = d3.geo.greatArc();

        svg.selectAll(".label")
            .attr("text-anchor",function(d) {
                var x = proj(d.geometry.coordinates)[0];
                return x < width/2-20 ? "end" :
                        x < width/2+20 ? "middle" : 
                        "start"
            })
            .attr("transform", function(d) {
                var loc = proj(d.geometry.coordinates),
                x = loc[0],
                y = loc[1];
                var offset = x < width/2 ? -5 : 5;
                return "translate(" + (x+offset) + "," + (y-2) + ")"
            })
            .style("display",function(d) {
                var d = arc.distance({source: d.geometry.coordinates, target: centerPos});
                return (d > 1.57) ? 'none' : 'inline';
            })
    }
    */
    function position_labels() { //how labels chage their angle
        var centerPos = proj.invert([width/2,height/2]);
        var arc = d3.geo.greatArc();

        svg.selectAll(".label")
            .attr("text-anchor",function(d) {
                var x = proj(d.geometry.coordinates)[0];
                return x < width/2-20 ? "start" :
                        x < width/2+20 ? "middle" : 
                        "end"
            })
            .attr("transform", function(d) {
                var loc = proj(d.geometry.coordinates),
                x = loc[0],
                y = loc[1];
                var offset = x < width/2 ? 5 : -5;
                return "translate(" + (x+offset) + "," + (y-2) + ")"
            })
            .style("display",function(d) {
                var d = arc.distance({source: d.geometry.coordinates, target: centerPos});
                return (d > 1.3) ? 'none' : 'inline';
            })
    }
    var m0, o0;
    function mousedown() {
        // d3.event => current event, if any.
        m0 = [d3.event.pageX, d3.event.pageY];
        o0 = proj.rotate();
        d3.event.preventDefault();
    }
    function mousemove() {
        if (m0) {
            var m1 = [d3.event.pageX, d3.event.pageY], 
                o1 = [o0[0] + (m1[0] - m0[0]) / 6, o0[1] + (m0[1] - m1[1]) / 6];
            o1[1] = o1[1] > 30  ? 30  :
                    o1[1] < -30 ? -30 :
                    o1[1];
            proj.rotate(o1);
            refresh();
        }
    }
    function mouseup() {
        if (m0) {
            mousemove();
            m0 = null;
        }
    }
    function refresh() {
        svg.selectAll(".land").attr("d", path);
        svg.selectAll(".countries path").attr("d", path);
        svg.selectAll(".graticule").attr("d", path);
        svg.selectAll(".point").attr("d", path);
        svg.selectAll(".fog").attr("d", path);
        svg.selectAll(".fogMask").attr("d", path);
        position_labels();
    }

</script>
</body>