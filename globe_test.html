<!DOCTYPE html>
<meta charset="utf-8">
<style>
.land {
    fill: rgb(117, 87, 57);
    stroke-opacity: 1;
}

.countries path {
    stroke: rgb(80, 64, 39);
    stroke-linejoin: round;
    stroke-width:.5;
    fill: rgb(117, 87, 57);
    opacity: .1;
}

.countries path:hover {
    fill-opacity:.1;
    stroke-width:1;
    opacity: 1;
}


.graticule {
    fill: none;
    stroke: black;
    stroke-width:.5;
    opacity:.2;
}

.labels {
    font: 8px sans-serif;
    fill: black;
}

.noclicks {
    pointer-events:none;
}

.point{
    opacity:.6;
}

.fog{
    fill: url(#fog);
    fill-rule: evenodd;
    opacity: 0.85;
}
.fogMask{
    fill: black;
    fill-rule: evenodd;
}
div.toolTipSelf {   
    position: absolute;         
    text-align: left;         
    width: 60px;                    
    height: 42px; /*14 multiply by 行數 */           
    padding: 2px;               
    font: 12px sans-serif;      
    background: lightsteelblue;
    border: 0px;        
    border-radius: 8px;         
    pointer-events: none;           
}
div.toolTipOther {   
    position: absolute;         
    text-align: left;         
    width: 60px;                    
    height: 56px; /*14 multiply by 行數 */           
    padding: 2px;               
    font: 12px sans-serif;      
    background: magenta; 
    border: 0px;        
    border-radius: 8px;         
    pointer-events: none;           
}
</style>

<body>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://d3js.org/queue.v1.min.js"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>
    <script src="troopClass.js"></script>
    <script src="https://d3js.org/d3-geo.v1.min.js"></script>
    <script>
    d3.select(window)
        .on("mousemove", mousemove)
        .on("mouseup", mouseup);

    // var width = 960, height = 500;
    var width = screen.width * 0.95, height = screen.height * 0.95;

    var proj = d3.geo.orthographic()
        .scale(220)
        .translate([width / 2, height / 2])
        .clipAngle(90);
    var preD, postD, pntD;
    // projection(location): that coordinates -> cartesian coordinates in pixels
    // projection.invert(point): cartesian coordinates [x,y] -> [longtitude, latitude]
    // projection.rotate([yaw, pitch, roll]) -> sets projection's three-axis rotation
    // projection.scale([scale]) -> scale factor of projection
    // projection.clipAngle -> semi-fog of war, how much degree to displaya
    // projection.translate([x, y]) -> offset projection's center coordinate
    var path = d3.geo.path().projection(proj).pointRadius(1);
    // d3.geo.path() -> given geoJSON object -> generate a SVG path
    var graticule = d3.geo.graticule();
    // graticule -> vertical and horizontal grid lines 
    // -> returns a GeoJSON MultiLineString Geometry object representing all meridians and parallels
    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height)
        .on("mousedown", mousedown);
    // Append group for containing hover info.
    var toolTip = d3.select("body").append("div")
        .style("opacity", 0);
    // asynchronous task assignment.
    queue()
        .defer(d3.json, "https://raw.githubusercontent.com/jonataswalker/map-utils/master/data/json/world-110m.json")
        .defer(d3.json, "https://raw.githubusercontent.com/DixonCider/fongmun2017/master/places.json")
        .await(ready);
    // svg -> defs: graphical macro for later use (not rendered immdiately)
    var vision = class vision {
        constructor(id, lat, lon, r){
            this.lat = lat;
            this.lon = lon;
            this.r = r;
            this.id = id;
            this.enable();
        }
        update(key, val) {
            if (this.hasOwnProperty(key)) {
                this[key] = val;
                var fogMaskCircle = d3.geoCircle().center([this.lat, this.lon]).radius(this.r);
                svg.select("#" + this.id)
                    .datum(fogMaskCircle())
                    .attr("d", path);
            }
        }
        disable(){
            svg.select("#" + this.id)
                .data([])
                .exit()
                .remove();
        }
        enable(){
            if (svg.select("#" + this.id)[0][0] == null) {
                var fogMaskCircle = d3.geoCircle().center([this.lat, this.lon]).radius(this.r);
                svg.select("#visionMask").append("path")
                    .datum(fogMaskCircle())
                    .attr("d", path)
                    .attr("class", "fogMask")
                    .attr("id", this.id)
                    .style("fill", "black");
            }
        }
    }

    var currentTroop = null;

    function ready(error, world, places) {
        var ocean_fill = svg.append("defs").append("radialGradient")
            .attr("id", "ocean_fill")
            .attr("cx", "75%")
            .attr("cy", "25%");
        // center of the ocean gradient
        ocean_fill.append("stop").attr("offset", "5%").attr("stop-color", "#ddf");
        ocean_fill.append("stop").attr("offset", "100%").attr("stop-color", "#9ab");
        // sunshine in the land
        var globe_highlight = svg.append("defs").append("radialGradient")
            .attr("id", "globe_highlight")
            .attr("cx", "75%")
            .attr("cy", "25%");
        globe_highlight.append("stop")
            .attr("offset", "5%").attr("stop-color", "#ffd")
            .attr("stop-opacity","0.6");
        globe_highlight.append("stop")
            .attr("offset", "100%").attr("stop-color", "#ba9")
            .attr("stop-opacity","0.2");
        var fogsize = 900;
        var fog = svg.append("defs").append("pattern")
            .attr("id", "fog")
            .attr("width", fogsize)
            .attr("height", fogsize)
            .attr("patternUnits", "userSpaceOnUse");
        fog.append("svg:image")
            .attr("xlink:href", "fog.webp")
            .attr("width", fogsize)
            .attr("height", fogsize)
            .attr("x", width / 3.5)
            .attr("y", height / 6);
        var globe_shading = svg.append("defs").append("radialGradient")
            .attr("id", "globe_shading")
            .attr("cx", "50%")
            .attr("cy", "40%");
        globe_shading.append("stop")
            .attr("offset","50%").attr("stop-color", "#9ab")
            .attr("stop-opacity","0")
        globe_shading.append("stop")
            .attr("offset","100%").attr("stop-color", "#3e6184")
            .attr("stop-opacity","0.3")
        var visionMask = svg.append("defs").append("mask")
            .attr("id", "visionMask");
            /*
        visionMask.append("circle")
            .attr("cx", width / 2).attr("cy", height / 2)
            .attr("r", proj.scale())
            .attr("class", "fogMask")
            .style("fill", "white");
            */
        var fogMotherMaskCircle = d3.geoCircle().center([0, 90]).radius(180);
        visionMask.append("path")
            .datum(fogMotherMaskCircle())
            .attr("d", path)
            .attr("class", "fogMask")
            .style("fill", "white");
        visionMask.append("g")
            .attr("class", "fogMasksSelf");
        visionMask.append("g")
            .attr("class", "fogMasksOthers");
            /*
        var fogMaskCircle = d3.geoCircle().center([120, 23.5]).radius(30);
        visionMask.append("path")
            .datum(fogMaskCircle())
            .attr("d", path)
            .attr("class", "fogMask")
            .style("fill", "black");
        
        visionMask.append("path")
            .data([fogMotherMaskCircle(), fogMaskCircle()])
            .attr("d", path)
            .attr("class", "fogMask")
            .style("fill", "white");
        */
        var visionClip = svg.append("defs").append("clipPath")
            .attr("id", "visionClip");
        visionClip.append("circle")
            .attr("cx", "300")
            .attr("cy", "300")
            .attr("r", "300");
        var drop_shadow = svg.append("defs").append("radialGradient")
            .attr("id", "drop_shadow")
            .attr("cx", "50%")
            .attr("cy", "50%");
        drop_shadow.append("stop")
            .attr("offset","20%").attr("stop-color", "#000")
            .attr("stop-opacity",".5")
        drop_shadow.append("stop")
            .attr("offset","100%").attr("stop-color", "#000")
            .attr("stop-opacity","0")
        // Shadow on the floor
        svg.append("ellipse")
            .attr("cx", width / 2 * 0.975).attr("cy", height / 2 * 1.6)
            .attr("rx", proj.scale()*.90)
            .attr("ry", proj.scale()*.25)
            .attr("class", "noclicks")
            .style("fill", "url(#drop_shadow)");
        // url(#patternDefinedInDefs)
        
        // ocean circle
        svg.append("circle")
            .attr("cx", width / 2).attr("cy", height / 2)
            .attr("r", proj.scale())
            .attr("class", "noclicks")
            .style("fill", "url(#ocean_fill)");
        // land color
        preD = topojson.feature(world, world.objects.land);
        svg.append("path")
            .datum(topojson.feature(world, world.objects.land))
            .attr("class", "land")
            .attr("d", path);
        postD = path(preD);
        // set verticals and parallel lines
        svg.append("path")
            .datum(graticule)
            .attr("class", "graticule noclicks")
            .attr("d", path);
        
        // points of locations
        pntD = places.features;
        svg.append("g").attr("class","points")
            .selectAll("text").data(places.features)
            .enter().append("path")
            .attr("class", "point")
            .attr("d", path);
        svg.append("g").attr("class","labels")
            .selectAll("text").data(places.features)
            .enter().append("text")
            .attr("class", "label")
            .text(function(d) { return d.properties.name });

        // append gray cover
        var fogCircle = d3.geoCircle().center([0,90]).radius(180);
        svg.append("path")
            .datum(fogCircle)
            .attr("class", "fog")
            .attr("d", path)
            .attr("mask", "url(#visionMask)");
        // sun shine land brighter
        svg.append("circle")
            .attr("cx", width / 2).attr("cy", height / 2)
            .attr("r", proj.scale())
            .attr("class","noclicks")
            .style("fill", "url(#globe_highlight)");
        // shadows on the side
        svg.append("circle")
            .attr("cx", width / 2).attr("cy", height / 2)
            .attr("r", proj.scale())
            .attr("class","noclicks")
            .style("fill", "url(#globe_shading)");
        // Append empty range of attack.
        var emptyCircle = d3.geoCircle().radius(0);
        svg.append("path")
            .datum(emptyCircle())
            .attr("id", "focusTroop")
            .attr("d", path)
            .style("fill", "turquoise")
            .style("opacity", 0.3)
            .on("mousedown", function(){
                if (currentTroop != null) {
                    // send request to change dest.
                    currentTroop.data()[0].dest = proj.invert([d3.event.pageX, d3.event.pageY]);
                    

                    var destDot = d3.geoCircle().center(currentTroop.data()[0].dest).radius(1);
                    var theDest = svg.select("#destDot")
                        .datum(destDot)
                        .attr("d", path)
                        .attr("transform", "translate(-7,-7)");
                    console.log([currentTroop.data()[0].loc[0], currentTroop.data()[0].loc[1]]);
                    console.log(proj.invert([d3.event.pageX - 7, d3.event.pageY - 7]));
                }
            });
        // Append destination red dot.
        svg.append("path")
            .datum(emptyCircle())
            .attr("id", "destDot")
            .attr("d", path)
            .style("fill", "red");
        // Append group for containing myTroops.
        svg.append("g")
            .attr("id", "myTroopGroup");
        // Append group for containing otherTroops.
        svg.append("g")
            .attr("id", "otherTroopGroup");
        position_labels();
    }
    function position_labels() { //how labels chage their angle
        var centerPos = proj.invert([width/2,height/2]);
        var arc = d3.geo.greatArc();

        svg.selectAll(".label")
            .attr("text-anchor",function(d) {
                var x = proj(d.geometry.coordinates)[0];
                return x < width/2-20 ? "start" :
                        x < width/2+20 ? "middle" : 
                        "end"
            })
            .attr("transform", function(d) {
                var loc = proj(d.geometry.coordinates),
                x = loc[0],
                y = loc[1];
                var offset = x < width/2 ? 5 : -5;
                return "translate(" + (x+offset) + "," + (y-2) + ")"
            })
            .style("display",function(d) {
                var d = arc.distance({source: d.geometry.coordinates, target: centerPos});
                return (d > 1.3) ? 'none' : 'inline';
            });
        // Troop must disappear outside of sphere.
        svg.selectAll(".myTroop")
            .style("display",function(d) {
                var d = arc.distance({source: d.loc, target: centerPos});
                return (d > 1.3) ? 'none' : 'block';
            });
        svg.selectAll(".notMyTroop")
            .style("display",function(d) {
                var d = arc.distance({source: d.loc, target: centerPos});
                return (d > 1.3) ? 'none' : 'block';
            });
    }
    var m0, o0;
    function mousedown() {
        // d3.event => current event, if any.
        m0 = [d3.event.pageX, d3.event.pageY];
        o0 = proj.rotate();
        d3.event.preventDefault();
    }
    function mousemove() {
        if (m0) {
            var m1 = [d3.event.pageX, d3.event.pageY], 
                o1 = [o0[0] + (m1[0] - m0[0]) / 6, o0[1] + (m0[1] - m1[1]) / 6];
            o1[1] = o1[1] > 30  ? 30  :
                    o1[1] < -30 ? -30 :
                    o1[1];
            proj.rotate(o1);
            refresh();
        }
    }
    function mouseup() {
        /*
        if (m0[0] == d3.event.pageX && m0[1] == d3.event.pageY) {
            if (currentTroop != null) {
                console.log(currentTroop.data()[0].loc);
                console.log(proj.invert(m0));
                console.log(d3.geoDistance(currentTroop.data()[0].loc,proj.invert(m0)) / Math.PI * 180);
            }
        }
        */
        if (m0) {
            mousemove();
            m0 = null;
        }
    }
    function refresh() {
        svg.selectAll(".land").attr("d", path);
        svg.selectAll(".countries path").attr("d", path);
        svg.selectAll(".graticule").attr("d", path);
        svg.selectAll(".point").attr("d", path);
        svg.selectAll(".fog").attr("d", path);
        svg.selectAll(".fogMask").attr("d", path);
        svg.select("#focusTroop").attr("d", path);
        svg.selectAll(".myTroop")
            .attr("x", function(d){return proj(d.loc)[0]})
            .attr("y", function(d){return proj(d.loc)[1]});
        svg.selectAll(".notMyTroop")
            .attr("x", function(d){return proj(d.loc)[0]})
            .attr("y", function(d){return proj(d.loc)[1]});
        position_labels();
    }
    function updateTroop(selfTroops, otherTroops){
        // Update self troop.
        var troopFogList = [];
        selfTroops.Troops.forEach(function(d){
            var fogCircleMask = d3.geoCircle().center([d.loc[0], d.loc[1]]).radius(d.fogR);
            troopFogList.push(fogCircleMask());
        });
        svg.selectAll(".myTroop")
            .data([])
            .exit()
            .remove();
        svg.select("#myTroopGroup")
            .selectAll("image")
            .data(selfTroops.Troops)
            .enter()
            .append("image")
            .attr("href", "troop.png")
            .attr("class", "myTroop")
            .attr("height", 10)
            .attr("width", 10)
            
            .attr("transform", function(d){
                var output = "translate(-" + (d.fogR/2) + ",-" + (d.fogR/2) + ")"
                return output;
            })
            .property("selected", false)
            .on("mousedown", function(data, index){
                // Reset all selected forall other nodes.
                svg.selectAll(".myTroop")
                    .filter(function(d, i) { return i != index})
                    .property("selected", false);
                // Modify this troop.
                currentTroop = d3.select(this);
                currentTroop.property("selected", !currentTroop.property("selected"));
                var newCircle = null;
                var opacityValue = 0.3;
                if (currentTroop.property("selected")) {
                    var src = currentTroop.data()[0];
                    newCircle = d3.geoCircle()
                        .center([src.loc[0], src.loc[1]])
                        .radius(src.attackR);
                    svg.select("#focusTroop")
                        .style("opacity", 0)
                        .datum(newCircle())
                        .attr("d", path);
                }
                else {
                    newCircle = d3.geoCircle().radius(0);
                    opacityValue = 0;
                    currentTroop = null;
                }
                svg.select("#focusTroop")
                    .transition()
                    .duration(300)
                    .style("opacity", opacityValue);
            })
            .on("mouseover", function(d){
                toolTip.attr("class", "toolTipSelf")
                    .transition()
                    .duration(200)
                    .style("opacity", 0.9);
                toolTip.html(function(){
                        var str = "#" + d.id + "<br/>"
                                + "AD: " + d.size * d.unitAD + "<br/>"
                                + "HP: " + d.size * d.unitHP + "<br/>";
                        return str;
                    })
                    .style("left", (d3.event.pageX) + "px")
                    .style("top", (d3.event.pageY - 42) + "px");    
            })
            .on("mouseout", function(){
                toolTip.transition()        
                    .duration(500)      
                    .style("opacity", 0);
            });
        // Update fog of war.
        svg.selectAll(".fogMasksSelf")
            .selectAll("path")
            .data([])
            .exit()
            .remove();
        svg.selectAll(".fogMasksSelf")
            .selectAll("path")
            .data(troopFogList)
            .enter()
            .append("path")
            .attr("d", path)
            .attr("class", "fogMask")
            .style("fill", "black");
        // Update other troop.
        svg.selectAll(".notMyTroop")
            .data([])
            .exit()
            .remove();
        svg.select("#otherTroopGroup")
            .append("g")
            .selectAll("image")
            .data(otherTroops.Troops)
            .enter()
            .append("image")
            .attr("href", "otherTroop.png")
            .attr("class", "notMyTroop")
            .attr("x", function(d){return proj(d.loc)[0]})
            .attr("y", function(d){return proj(d.loc)[1]})
            .attr("height", 10)
            .attr("width", 10)
            .attr("transform", "translate(-5,-5)")
            .on("mouseover", function(d){
                toolTip.attr("class", "toolTipOther")
                    .transition()
                    .duration(200)
                    .style("opacity", 0.9);
                toolTip.html(function(){
                        var str = d.country + "<br/>"
                                + "#" + d.id + "<br/>"
                                + "AD: " + d.AD + "<br/>"
                                + "HP: " + d.HP + "<br/>";
                        return str;
                    })
                    .style("left", (d3.event.pageX + 15) + "px")
                    .style("top", (d3.event.pageY - 40) + "px");    
            })
            .on("mouseout", function(){
                toolTip.transition()        
                    .duration(500)      
                    .style("opacity", 0);
            });
        // Refresh display.
        refresh();
    }
</script>
</body>