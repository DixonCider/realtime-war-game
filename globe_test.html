<!DOCTYPE html>
<meta charset="utf-8">
<head>
    <link rel="stylesheet" type="text/css" href="styling.css">
</head>
<body>
    <h1>FONNGMUN</h1>
    <p>Round 1 Current Time: 10:00</p>
    <div class="techtree">
        <button class="ctrl-standard fx-bubbleUp">Tech<br>Tree</button>
    </div>
    <div class="logout"> 
         <button class="ctrl-standard fx-bubbleDown">Log<br>Out</button>
    </div>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://d3js.org/queue.v1.min.js"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>
    <script src="https://d3js.org/d3-geo.v1.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script>

    // console.log(screen.width);

    d3.select(window)
        .on("mousemove", mousemove)
        .on("mouseup", mouseup);

    // var width = 960, height = 500;
    var width = screen.width * 0.95, height = screen.height * 0.95;

    var proj = d3.geo.orthographic()
        .scale(300)
        .translate([width / 2, height / 2])
        .clipAngle(90);
    var preD, postD, pntD;
    // projection(location): that coordinates -> cartesian coordinates in pixels
    // projection.invert(point): cartesian coordinates [x,y] -> [longtitude, latitude]
    // projection.rotate([yaw, pitch, roll]) -> sets projection's three-axis rotation
    // projection.scale([scale]) -> scale factor of projection
    // projection.clipAngle -> semi-fog of war, how much degree to displaya
    // projection.translate([x, y]) -> offset projection's center coordinate
    var path = d3.geo.path().projection(proj).pointRadius(1);
    // d3.geo.path() -> given geoJSON object -> generate a SVG path
    var graticule = d3.geo.graticule();
    // graticule -> vertical and horizontal grid lines 
    // -> returns a GeoJSON MultiLineString Geometry object representing all meridians and parallels
    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height)
        .attr("x", 0)
        .attr("y", 0)
        .attr("position", "absolute")
        .on("mousedown", mousedown);
    // Append group for containing hover info.
    var toolTip = d3.select("body").append("div")
        .style("opacity", 0);
    var totalCountryList = ["DPRK", "USA", "Korea", "Russia", "ROC", "Japan", "Mexico", "India", "Phillipines", "Vietnam"];
    /*
    var createContainer = d3.select("body").append("div")
        .style("position", "absolute")
        .style("bottom", "20px")
        .style("right", "20px");
    createContainer.append("label")
        .style("color", "white")
        .property("innerHTML", "Create Mode");
    createContainer.append("input")
        .attr("type", "checkbox")
        .attr("id", "CreateMode");
    */
    var friendOrEnemyCheckbox = d3.select("body").append("div")
        .attr("id", "friendOrEnemyContainer")
        .style("color", "white")
        .style("position", "absolute")
        .style("bottom", "20px")
        .style("left", "20px")
        .property("innerHTML", "Enemy List")
        .selectAll("input")
        .data(totalCountryList)
        .enter()
        .append("div");
    friendOrEnemyCheckbox.append("input")
        .attr("type", "checkbox")
        .on("change", function(d){
            var checkedList = [];
            d3.select("#friendOrEnemyContainer").selectAll("input").each(function(d, i){
                if (d3.select(this).property("checked") == true) {
                    checkedList.push(d);
                }
            });
            // Send request to change enemyList
            // d is the name of the changed country
            // this.checked == isEnemy
            // thisCountry is this country
        });
    friendOrEnemyCheckbox.append("label")
        .style("color", "white")
        .property("innerHTML", function(d){
            return d;
        });
    // asynchronous task assignment.
    queue()
        .defer(d3.json, "https://raw.githubusercontent.com/jonataswalker/map-utils/master/data/json/world-110m.json")
        .defer(d3.json, "https://raw.githubusercontent.com/DixonCider/fongmun2017/master/places.json")
        .await(ready);
    // svg -> defs: graphical macro for later use (not rendered immdiately)
    var emptyGeoCircle = d3.geoCircle().radius(0)();
    var emptyGeoLineString = {
        "type": "LineString",
        "coordinates": [ [0,0], [0,0] ]
    };
    var thisCountry = null;
    var vision = class vision {
        constructor(id, lat, lon, r){
            this.lat = lat;
            this.lon = lon;
            this.r = r;
            this.id = id;
            this.enable();
        }
        update(key, val) {
            if (this.hasOwnProperty(key)) {
                this[key] = val;
                var fogMaskCircle = d3.geoCircle().center([this.lat, this.lon]).radius(this.r);
                svg.select("#" + this.id)
                    .datum(fogMaskCircle())
                    .attr("d", path);
            }
        }
        disable(){
            svg.select("#" + this.id)
                .data([])
                .exit()
                .remove();
        }
        enable(){
            if (svg.select("#" + this.id)[0][0] == null) {
                var fogMaskCircle = d3.geoCircle().center([this.lat, this.lon]).radius(this.r);
                svg.select("#visionMask").append("path")
                    .datum(fogMaskCircle())
                    .attr("d", path)
                    .attr("class", "fogMask")
                    .attr("id", this.id)
                    .style("fill", "black");
            }
        }
    }

    var currentTroop = null;

    function ready(error, world, places) {
        var ocean_fill = svg.append("defs").append("radialGradient")
            .attr("id", "ocean_fill")
            .attr("cx", "75%")
            .attr("cy", "25%");
        // center of the ocean gradient
        ocean_fill.append("stop").attr("offset", "5%").attr("stop-color", "#ddf");
        ocean_fill.append("stop").attr("offset", "100%").attr("stop-color", "#9ab");
        // sunshine in the land
        var globe_highlight = svg.append("defs").append("radialGradient")
            .attr("id", "globe_highlight")
            .attr("cx", "75%")
            .attr("cy", "25%");
        globe_highlight.append("stop")
            .attr("offset", "5%").attr("stop-color", "#ffd")
            .attr("stop-opacity","0.6");
        globe_highlight.append("stop")
            .attr("offset", "100%").attr("stop-color", "#ba9")
            .attr("stop-opacity","0.2");
        var fogsize = 900;
        var fog = svg.append("defs").append("pattern")
            .attr("id", "fog")
            .attr("width", width)
            .attr("height", height)
            .attr("patternUnits", "userSpaceOnUse");
        fog.append("svg:image")
            .attr("xlink:href", "fog.webp")
            .attr("width", width)
            .attr("height", height);
        var globe_shading = svg.append("defs").append("radialGradient")
            .attr("id", "globe_shading")
            .attr("cx", "50%")
            .attr("cy", "40%");
        globe_shading.append("stop")
            .attr("offset","50%").attr("stop-color", "#9ab")
            .attr("stop-opacity","0")
        globe_shading.append("stop")
            .attr("offset","100%").attr("stop-color", "#3e6184")
            .attr("stop-opacity","0.3")
        var visionMask = svg.append("defs").append("mask")
            .attr("id", "visionMask");
            /*
        visionMask.append("circle")
            .attr("cx", width / 2).attr("cy", height / 2)
            .attr("r", proj.scale())
            .attr("class", "fogMask")
            .style("fill", "white");
            */
        var fogMotherMaskCircle = d3.geoCircle().center([0, 90]).radius(180);
        visionMask.append("path")
            .datum(fogMotherMaskCircle())
            .attr("d", path)
            .attr("class", "fogMask")
            .style("fill", "white");
        visionMask.append("g")
            .attr("class", "fogMasksSelf");
        visionMask.append("g")
            .attr("class", "fogMasksOthers");
            /*
        var fogMaskCircle = d3.geoCircle().center([120, 23.5]).radius(30);
        visionMask.append("path")
            .datum(fogMaskCircle())
            .attr("d", path)
            .attr("class", "fogMask")
            .style("fill", "black");
        
        visionMask.append("path")
            .data([fogMotherMaskCircle(), fogMaskCircle()])
            .attr("d", path)
            .attr("class", "fogMask")
            .style("fill", "white");
        */
        var drop_shadow = svg.append("defs").append("radialGradient")
            .attr("id", "drop_shadow")
            .attr("cx", "50%")
            .attr("cy", "50%");
        drop_shadow.append("stop")
            .attr("offset","20%").attr("stop-color", "#000")
            .attr("stop-opacity",".5")
        drop_shadow.append("stop")
            .attr("offset","100%").attr("stop-color", "#000")
            .attr("stop-opacity","0")
        // Shadow on the floor
        svg.append("ellipse")
            .attr("cx", width / 2 * 0.975).attr("cy", height / 2 * 1.6)
            .attr("rx", proj.scale()*.90)
            .attr("ry", proj.scale()*.25)
            .attr("class", "noclicks")
            .style("fill", "url(#drop_shadow)");
        // url(#patternDefinedInDefs)
        
        // ocean circle
        svg.append("circle")
            .attr("cx", width / 2).attr("cy", height / 2)
            .attr("r", proj.scale())
            .attr("class", "noclicks")
            .style("fill", "url(#ocean_fill)");
        // land color
        preD = topojson.feature(world, world.objects.land);
        svg.append("path")
            .datum(topojson.feature(world, world.objects.land))
            .attr("class", "land")
            .attr("d", path);
        postD = path(preD);
        // set verticals and parallel lines
        svg.append("path")
            .datum(graticule)
            .attr("class", "graticule noclicks")
            .attr("d", path);
        
        // points of locations
        pntD = places.features;
        svg.append("g").attr("class","points")
            .selectAll("text").data(places.features)
            .enter().append("path")
            .attr("class", "point")
            .attr("d", path);
        svg.append("g").attr("class","labels")
            .selectAll("text").data(places.features)
            .enter().append("text")
            .attr("class", "label")
            .text(function(d) { return d.properties.name });

        // append gray cover
        var fogCircle = d3.geoCircle().center([0,90]).radius(180);
        svg.append("path")
            .datum(fogCircle)
            .attr("class", "fog")
            .attr("d", path)
            .attr("mask", "url(#visionMask)");
        // sun shine land brighter
        svg.append("circle")
            .attr("cx", width / 2).attr("cy", height / 2)
            .attr("r", proj.scale())
            .attr("class","noclicks")
            .style("fill", "url(#globe_highlight)");
        // shadows on the side
        svg.append("circle")
            .attr("cx", width / 2).attr("cy", height / 2)
            .attr("r", proj.scale())
            .attr("class","noclicks")
            .style("fill", "url(#globe_shading)");
        // Group for containing resource points.
        svg.append("g")
            .attr("class", "resources");
        var emptyCircle = d3.geoCircle().radius(0);
        // Append destination red dot.
        svg.append("path")
            .datum(emptyCircle())
            .attr("id", "destDot")
            .attr("d", path)
            .style("fill", "red");
        // Add doted path to destination.
        svg.append("path")
            .attr("id", "destPath")
            .style("stroke", "red")
            .style("fill", "none")
            .style("stroke-dasharray", "2, 2");
        // Append group for containing myTroops.
        svg.append("g")
            .attr("id", "myTroopGroup");
        // Append group for containing otherTroops.
        svg.append("g")
            .attr("id", "otherTroopGroup");
        position_labels();
    }
    function position_labels() { //how labels chage their angle
        var centerPos = proj.invert([width/2,height/2]);
        var arc = d3.geo.greatArc();

        svg.selectAll(".label")
            .attr("text-anchor",function(d) {
                var x = proj(d.geometry.coordinates)[0];
                return x < width/2-20 ? "start" :
                        x < width/2+20 ? "middle" : 
                        "end"
            })
            .attr("transform", function(d) {
                var loc = proj(d.geometry.coordinates),
                x = loc[0],
                y = loc[1];
                var offset = x < width/2 ? 5 : -5;
                return "translate(" + (x+offset) + "," + (y-2) + ")"
            })
            .style("display",function(d) {
                var d = arc.distance({source: d.geometry.coordinates, target: centerPos});
                return (d > 1.3) ? 'none' : 'inline';
            });
        svg.selectAll(".point")
            .style("display",function(d) {
                var d = arc.distance({source: d.geometry.coordinates, target: centerPos});
                return (d > 1.3) ? 'none' : 'block';
            });
        // Troop must disappear outside of sphere.
        svg.selectAll(".myTroop")
            .style("display",function(d) {
                var d = arc.distance({source: d.loc, target: centerPos});
                return (d > 1.3) ? 'none' : 'block';
            });
        svg.selectAll(".notMyTroop")
            .style("display",function(d) {
                var d = arc.distance({source: d.loc, target: centerPos});
                return (d > 1.3) ? 'none' : 'block';
            });
    }
    var m0, o0;
    function mousedown() {
        // d3.event => current event, if any.
        m0 = [d3.event.pageX, d3.event.pageY];
        o0 = proj.rotate();
        d3.event.preventDefault();


    }
    function mousemove() {
        if (m0) {
            var m1 = [d3.event.pageX, d3.event.pageY], 
                o1 = [o0[0] + (m1[0] - m0[0]) / 6, o0[1] + (m0[1] - m1[1]) / 6];
            /*
            o1[1] = o1[1] > 30  ? 30  :
                    o1[1] < -30 ? -30 :
                    o1[1];
            */
            proj.rotate(o1);
            refresh();
        }
    }
    function mouseup() {
        if (m0[0] == d3.event.pageX && m0[1] == d3.event.pageY) {
            console.log(proj.invert([d3.event.pageX - 7, d3.event.pageY - 7]));
            var centerPos = proj.invert([width/2,height/2]);
            var arc = d3.geo.greatArc();
            var d = arc.distance({source: proj.invert([d3.event.pageX - 7, d3.event.pageY - 7]), target: centerPos});
            if (currentTroop != null && d3.event.target != currentTroop[0][0] && d < Math.PI / 2) {
                // send request to change dest.
                currentTroop.data()[0].dest = proj.invert([d3.event.pageX - 7, d3.event.pageY - 7]);
                $.ajax(
                    `${serverURL}/updateDest`, {
                        method: 'post',
                        data: currentTroop.data()[0]
                    }
                )
                var destDot = d3.geoCircle().center(currentTroop.data()[0].dest).radius(0.7);
                var theDest = svg.select("#destDot")
                    .datum(destDot)
                    .attr("d", path);
                // Render the path.
                var pathLineString = {
                    "type": "LineString",
                    "coordinates": [
                        currentTroop.data()[0].loc, currentTroop.data()[0].dest
                    ]
                };
                // console.log(pathLineString);
                var destPath = d3.geoPath(pathLineString);
                // console.log(destPath());
                var thePath = svg.select("#destPath")
                    .datum(pathLineString)
                    .attr("d", path);
                // console.log(currentTroop.data()[0].loc);
                // console.log(currentTroop.data()[0].dest);
            }
        }
        
        if (m0) {
            mousemove();
            m0 = null;
        }
    }
    function refresh() {
        svg.selectAll(".land").attr("d", path);
        svg.selectAll(".countries path").attr("d", path);
        svg.selectAll(".graticule").attr("d", path);
        svg.selectAll(".point").attr("d", path);
        svg.selectAll(".fog").attr("d", path);
        svg.selectAll(".fogMask").attr("d", path);
        svg.select("#focusTroop").attr("d", path);
        svg.selectAll(".myTroop")
            .attr("x", function(d){return proj(d.loc)[0]})
            .attr("y", function(d){return proj(d.loc)[1]});
        svg.selectAll(".notMyTroop")
            .attr("x", function(d){return proj(d.loc)[0]})
            .attr("y", function(d){return proj(d.loc)[1]});
        svg.select("#destDot").attr("d", path);
        svg.select("#destPath").attr("d", path);
        svg.select(".resource").attr("d", path);
        svg.selectAll(".attackRange").attr("d", path);
        position_labels();
    }
    function updateResource(resourcePoints){
        svg.selectAll(".resource")
            .data([])
            .exit()
            .remove();
        svg.select(".resources").selectAll("path")
            .data(function(){
                var resourceCircle = [];
                resourcePoints.forEach(function(d){
                    var r = d3.geoCircle().center([d.loc[0], d.loc[1]]).radius(d.r)();
                    resourceCircle.push(r);
                });
                return resourceCircle;
            })
            .enter()
            .append("path")
            .attr("class", "resource")
            .attr("fill", "red")
            .style("fill-opacity", "0.2")
            .attr("stroke", "red")
            .style("stroke-opacity", 0.4)
            .style("stroke-width", 1)
            .style("stroke-dasharray", "5, 5")
            .attr("d", path);
    }
    function updateTroop(selfTroops, otherTroops){
        thisCountry = selfTroops.Nation;
        // Update checkbox.
        d3.select("#friendOrEnemyContainer").selectAll("input")
            .filter(function(d) { return d == thisCountry}).property("disabled", "true")
        // Update self troop.
        var troopFogList = [];
        selfTroops.Troops.forEach(function(d){
            var fogCircleMask = d3.geoCircle().center([d.loc[0], d.loc[1]]).radius(d.fogR);
            troopFogList.push(fogCircleMask());
        });
        svg.selectAll(".attackRange")
            .data([])
            .exit()
            .remove();
        // attack Range
        svg.select("#myTroopGroup")
            .selectAll("path")
            .data(function(){
                var aryAttackR = [];
                selfTroops.Troops.forEach(function(d){
                    var attackRCircle = d3.geoCircle().center(d.loc).radius(d.attackR)();
                    aryAttackR.push(attackRCircle);
                });
                return aryAttackR;
            })
            .enter()
            .append("path")
            .attr("d", path)
            .attr("class", "attackRange")
            .style("fill", "turquoise")
            .style("opacity", 0.3);
        svg.selectAll(".myTroop")
            .data([])
            .exit()
            .remove();
        svg.select("#myTroopGroup")
            .selectAll("image")
            .data(selfTroops.Troops)
            .enter()
            .append("image")
            .attr("href", thisCountry + ".png")
            .attr("class", "myTroop")
            .attr("height", 10)
            .attr("width", 10)
            .attr("transform", function(d){
                var output = "translate(-" + (d.fogR/2) + ",-" + (d.fogR/2) + ")"
                return output;
            })
            .property("selected", false)
            .on("mousedown", function(data, index){
                // Reset all selected forall other nodes.
                svg.selectAll(".myTroop")
                    .filter(function(d, i) { return i != index})
                    .property("selected", false);
                // Modify this troop.
                currentTroop = d3.select(this);
                currentTroop.property("selected", !currentTroop.property("selected"));
                var newCircle = null;
                var opacityValue = 0.3;
                // Render red dot.
                if (currentTroop.data()[0].dest != null) {
                    var destDot = d3.geoCircle().center(currentTroop.data()[0].dest).radius(1);
                    var theDest = svg.select("#destDot")
                        .datum(destDot)
                        .attr("opacity", 0)
                        .attr("d", path);
                    theDest.transition()
                        .duration(400)
                        .attr("opacity", 1);
                    // Render the path.
                    var pathLineString = {
                        "type": "LineString",
                        "coordinates": [
                            currentTroop.data()[0].loc, currentTroop.data()[0].dest
                        ]
                    };
                    var destPath = d3.geoPath(pathLineString);
                    var thePath = svg.select("#destPath")
                        .datum(pathLineString)
                        .attr("opacity", 0)
                        .attr("d", path);
                    thePath.transition()
                        .duration(400)
                        .attr("opacity", 1);
                }
                else {
                    svg.select("#destDot")
                        .datum(emptyGeoCircle)
                        .attr("d", path);
                    svg.select("#destPath")
                        .datum(emptyGeoLineString)
                        .attr("d", path);
                }
                if (currentTroop.property("selected")) {
                    var src = currentTroop.data()[0];
                    newCircle = d3.geoCircle()
                        .center([src.loc[0], src.loc[1]])
                        .radius(src.attackR);
                    svg.select("#focusTroop")
                        .style("opacity", 0)
                        .datum(newCircle())
                        .attr("d", path);
                }
                else {
                    opacityValue = 0;
                    currentTroop = null;
                    svg.select("#destDot")
                        .datum(emptyGeoCircle)
                        .attr("d", path);
                    svg.select("#destPath")
                        .datum(emptyGeoLineString)
                        .attr("d", path);
                }

                svg.select("#focusTroop")
                    .transition()
                    .duration(300)
                    .style("opacity", opacityValue);
            })
            .on("mouseover", function(d){
                toolTip.attr("class", "toolTipSelf")
                    .transition()
                    .duration(200)
                    .style("opacity", 0.9);
                toolTip.html(function(){
                        var str = "#" + d.id + "<br/>"
                                + "AD: " + Math.round(d.size * d.unitAD) + "<br/>"
                                + "HP: " + Math.round(d.size * d.unitHP) + "<br/>";
                        return str;
                    })
                    .style("left", (d3.event.pageX) + "px")
                    .style("top", (d3.event.pageY - 42) + "px");    
            })
            .on("mouseout", function(){
                toolTip.transition()        
                    .duration(500)      
                    .style("opacity", 0);
            });
        // Update currentTroop.
        if (currentTroop != null) {
            var countryName = currentTroop.data()[0].country;
            var countryID = currentTroop.data()[0].id;
            currentTroop = svg.selectAll(".myTroop")
                .filter(function(d) { return d.id == countryID});
            // Render red dot.
            if (currentTroop.data()[0].dest != null) {
                var destDot = d3.geoCircle().center(currentTroop.data()[0].dest).radius(1);
                var theDest = svg.select("#destDot")
                    .datum(destDot)
                    .attr("opacity", 1)
                    .attr("d", path);
                // Render the path.
                var pathLineString = {
                    "type": "LineString",
                    "coordinates": [
                        currentTroop.data()[0].loc, currentTroop.data()[0].dest
                    ]
                };
                var destPath = d3.geoPath(pathLineString);
                var thePath = svg.select("#destPath")
                    .datum(pathLineString)
                    .attr("opacity", 1)
                    .attr("d", path);
            }
            else {
                svg.select("#destDot")
                    .datum(emptyGeoCircle)
                    .attr("d", path);
                svg.select("#destPath")
                    .datum(emptyGeoLineString)
                    .attr("d", path);
            }
        }
        // Update fog of war.
        svg.selectAll(".fogMasksSelf")
            .selectAll("path")
            .data([])
            .exit()
            .remove();
        svg.selectAll(".fogMasksSelf")
            .selectAll("path")
            .data(troopFogList)
            .enter()
            .append("path")
            .attr("d", path)
            .attr("class", "fogMask")
            .style("fill", "black");
        // Update other troop.
        svg.selectAll(".notMyTroop")
            .data([])
            .exit()
            .remove();
        svg.select("#otherTroopGroup")
            .append("g")
            .selectAll("image")
            .data(otherTroops.Troops)
            .enter()
            .append("image")
            .attr("href", function(d){
                return d.country + ".png";
            })
            .attr("class", "notMyTroop")
            .attr("x", function(d){return proj(d.loc)[0]})
            .attr("y", function(d){return proj(d.loc)[1]})
            .attr("height", 10)
            .attr("width", 10)
            .attr("transform", "translate(-5,-5)")
            .on("mouseover", function(d){
                toolTip.attr("class", "toolTipOther")
                    .transition()
                    .duration(200)
                    .style("opacity", 0.9);
                toolTip.html(function(){
                        var str = d.country + "<br/>"
                                + "#" + d.id + "<br/>"
                                + "AD: " + d.AD + "<br/>"
                                + "HP: " + d.HP + "<br/>";
                        return str;
                    })
                    .style("left", (d3.event.pageX + 15) + "px")
                    .style("top", (d3.event.pageY - 40) + "px");    
            })
            .on("mouseout", function(){
                toolTip.transition()        
                    .duration(500)      
                    .style("opacity", 0);
            });
        // Refresh display.
        refresh();
    }

    let countryData = {};
    let otherData = {};
    const myCountry = 'DPRK';
    const serverURL = 'http://192.168.1.212:8000/api';

    
    $.get(`${serverURL}/getMyTroops`, {country: myCountry} , function (data, status) {
            countryData = data.countryData;
            otherData = data.otherData;
            updateTroop(data.countryData, data.otherData)
            setTimeout(gameLoop, 100);
        });

    function gameLoop() {
        // console.log(countryData.Troops.filter(troop => troop.id == 24)[0].dest)
        const myTroops = svg.selectAll(".myTroop").data()
        myCountry.Troops = myTroops
        // console.log(myTroops.filter(troop => troop.id == 20)[0].dest)
        $.post(`${serverURL}/update`, { country: myCountry, data: JSON.stringify({ countryData, otherData}) }, function (data, status) {
            updateTroop(data.countryData, data.otherData)
            setTimeout(gameLoop, 1000);
         });
     }
    
</script>
</body>